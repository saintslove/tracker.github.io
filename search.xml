<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go多进程---信号]]></title>
    <url>%2F2018%2F05%2F15%2FGo%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[&ensp;查看源码程序&ensp;&ensp;&ensp;源码下载 &ensp;os.Signal接口类型如下： 1234567// A Signal represents an operating system signal.// The usual underlying implementation is operating system-dependent:// on Unix it is syscall.Signal.type Signal interface &#123; String() string Signal() // to distinguish from other Stringers&#125; &ensp;Signal方法没有实际意义，仅作为区别其他信号的标识，在GO标准库中，所有实现此接口类型的值均可作为操作系统信号。操作系统信号量类型均为syscall.Sinal,其为os.Signal接口的实现类，每一个信号常量均为隐含式整数，其整数值与所在操作系统代表的信号常量编号一致。 &ensp;Notify函数用于监控操作系统向当前进程所发的指定信号，其实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Notify causes package signal to relay incoming signals to c.// If no signals are provided, all incoming signals will be relayed to c.// Otherwise, just the provided signals will.//// Package signal will not block sending to c: the caller must ensure// that c has sufficient buffer space to keep up with the expected// signal rate. For a channel used for notification of just one signal value,// a buffer of size 1 is sufficient.//// It is allowed to call Notify multiple times with the same channel:// each call expands the set of signals sent to that channel.// The only way to remove signals from the set is to call Stop.//// It is allowed to call Notify multiple times with different channels// and the same signals: each channel receives copies of incoming// signals independently.func Notify(c chan&lt;- os.Signal, sig ...os.Signal) &#123; if c == nil &#123; panic("os/signal: Notify using nil channel") &#125; handlers.Lock() defer handlers.Unlock() h := handlers.m[c] if h == nil &#123; if handlers.m == nil &#123; handlers.m = make(map[chan&lt;- os.Signal]*handler) &#125; h = new(handler) handlers.m[c] = h &#125; add := func(n int) &#123; if n &lt; 0 &#123; return &#125; if !h.want(n) &#123; h.set(n) if handlers.ref[n] == 0 &#123; enableSignal(n) &#125; handlers.ref[n]++ &#125; &#125; if len(sig) == 0 &#123; for n := 0; n &lt; numSig; n++ &#123; add(n) &#125; &#125; else &#123; for _, s := range sig &#123; add(signum(s)) &#125; &#125;&#125; &ensp;参量c chan&lt;- os.Signal为发送通道，即仅可想其发送os.Signal类型的信号，参量sig ...os.Signal即为自定义信号量集合，当该参量为空，表示所有接收的常量信号均为自定义信号，逐一封装并存入c chan&lt;- os.Signal通道,coder如下： 123456789if len(sig) == 0 &#123; for n := 0; n &lt; numSig; n++ &#123; add(n) &#125; &#125; else &#123; for _, s := range sig &#123; add(signum(s)) &#125; &#125; &ensp;Notify函数以c chan&lt;- os.Signal接收通道为唯一标识符处理相应的信号集合，源码中信号集合字典m map[chan&lt;- os.Signal]*handler以signal接受通道及信号集合变体为键值对，若该键值对不存在，则注册信号接收申请，否则更新相应的键值对，coder如下： 12345678h := handlers.m[c] if h == nil &#123; if handlers.m == nil &#123; handlers.m = make(map[chan&lt;- os.Signal]*handler) &#125; h = new(handler) handlers.m[c] = h &#125; &ensp;若自定义信号量为syscall.SIGQUIT及syscall.SIGINT，示例如下： 123456789101112sigRecv1 := make(chan os.Signal, 1)sigs1 := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;fmt.Printf("Set notification for %s... [sigRecv1]\n", sigs1)signal.Notify(sigRecv1, sigs1...)fmt.Println("Wait for 2 seconds... ")time.Sleep(2 * time.Second)fmt.Printf("Stop notification...")for _, sig := range sigRecv1&#123; fmt.Printf("Receive a signal:%s\n",sig)&#125;signal.Stop(sigRecv1)close(sigRecv1) &ensp;Stop函数用于恢复系统对其默认操作，其声明如下,但其signal接受通道参量必须与Notify函数signal信号接收通道为同一参量，调用之后signal接受通道不在接收任何常量信号，会导致示例中for语句阻塞，为此，可通过close函数关闭signal接收通道 1234567891011121314// Stop causes package signal to stop relaying incoming signals to c.// It undoes the effect of all prior calls to Notify using c.// When Stop returns, it is guaranteed that c will receive no more signals.func Stop(c chan&lt;- os.Signal)// The close built-in function closes a channel, which must be either// bidirectional or send-only. It should be executed only by the sender,// never the receiver, and has the effect of shutting down the channel after// the last sent value is received. After the last value has been received// from a closed channel c, any receive from c will succeed without// blocking, returning the zero value for the channel element. The form// x, ok := &lt;-c// will also set ok to false for a closed channel.func close(c chan&lt;- Type) &ensp;若前后signal接受通道不同，signal处理程序会视为两个完全不同的操作，其实际效果如下： 123456789sigRecv1 := make(chan os.Signal, 1)sigs1 := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;fmt.Printf("Set notification for %s... [sigRecv1]\n", sigs1)signal.Notify(sigRecv1, sigs1...) sigRecv2 := make(chan os.Signal, 1)sigs2 := []os.Signal&#123;syscall.SIGQUIT&#125;fmt.Printf("Set notification for %s... [sigRecv2]\n", sigs2)signal.Notify(sigRecv2, sigs2...) &ensp;for语句的阻塞会影响程序的并发运行，需要通过go chan协程，同时为保障主程序在并发执行程序完成后退出，需要通过WaitGroup保障，示例如下： 12345678910111213141516171819sigRecv1 := make(chan os.Signal, 1)sigs1 := []os.Signal&#123;syscall.SIGINT, syscall.SIGQUIT&#125;fmt.Printf("Set notification for %s... [sigRecv1]\n", sigs1)signal.Notify(sigRecv1, sigs1...)var wg sync.WaitGroupwg.Add(2)go func() &#123; for sig := range sigRecv1 &#123; fmt.Printf("Received a signal from sigRecv1: %s\n", sig) &#125; fmt.Printf("End. [sigRecv1]\n") wg.Done()&#125;()signal.Stop(sigRecv1)close(sigRecv1)fmt.Printf("done. [sigRecv1]\n")wg.Wait()]]></content>
      <categories>
        <category>Go多进程</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“Go线程实现模型”]]></title>
    <url>%2F2018%2F05%2F11%2FGo%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[进程的状态 &ensp;可中断睡眠状态(S)：处于此状态的进程会被等待事件激活，否则被放入对应的事件等待队列 &ensp;不可中断睡眠状态(D)：处于该状态的进程不会对外界事件做出响应，直至退出该状态，事件信号才会传给该进程 &ensp;暂停或跟踪状态(T)：信号SIGSTOP会使相应进程转入该状态，除非进程处于不可中断睡眠状态，通过信号SIGCONT`会使进程转入可运行状态 线程的状态 线程运行队列内部结构示意图 线程实现模型1. 用户级线程模型 &ensp;应用程序对线程进行创建、终止、同步及切换等操作，无需切换用户态至内核态，对线程的管理完全无需内核的参与，因此具有高速、移植性强的优点。但该模型的多线程不可真正的高并发执行，因为进程是内核调度的基本单位，线程是资源分配的基本单位，同一进程内的众多线程优先级只能由所属进程优先级体现。 2. 内核级线程模型 &ensp;该模型的线程均由内核负责管理，需要更多的内核资源，同一进程内的每个线程均与一个KSE(Kernel Scheduling Entity)对应，即内核可以调度每一个线程，以此可以真正实现高并发。 3. 两级线程模型 &ensp;该模型的进程可关联多个KSE，但同一个进程中的线程并不与KSE一一对应，进程中的线程可映射至同一个已关联的KSE。 线程实现模型详解 &ensp;M: &ensp;&ensp;&ensp;代表一个内核线程，即工作线程，M与KSE一一对应。系统在停用M时，会将其放入调度器的空闲M列表(runtime.sched.midle)，因为系统在获取一个未被使用的M时，优先从该列表中选取，M空闲的标志是其是否位于该列表中。单个Go程序可运行的M数量可通过runtime/debug.SetMaxThreads设置，最大为10000，相当于可有10000个内核线程服务于当前Go程序。 &ensp;P:&ensp;&ensp;&ensp;一个Go代码片段运行所需要的上下文环境，M与P一一对应，两者共同构建了G有效的运行环境，每个P均包含一个可运行的G队列以及一个自由G列表，该列表包含已运行完成的G片段，当go欲启用一个G时，会优先从自由列表中获取一个G并用其封装go函数，若其对应的自由列表为空时，会从调度器的自由列表中转移一部分，若调度器也为空，，则创建新的G。P是G可运行的关键，其可通过runtime.GOMAXPROCS设置数值，最大值为256，默认值与当前系统的CPU核心数相同，当运行该函数时，会使所有P脱离运行状态，并试图阻止任何用户级别的G代码执行，因此最好在main函数起始处提前设置。重置P会使系统重整全局P列表，其包含系统创建的所有P，系统运行时会将本地P中可运行G全部转入调度器可运行G列表，当本地P的可运行G列表为空，其不再与M关联，系统鬼将其放入调度器空闲P列表。 &ensp;G:&ensp;&ensp;&ensp;用于封装一个Go代码片段，P与G是一对多关系。go语句的调用实际是系统对内部函数newproc的调用，系统通过从P或调度器的自由列表中抽取一个G用于封装go函数，随后将其放入全局G列表(runtime.allgs),该列表存放当前系统中所有G指针。运行时系统对其进行一次初始化，并存储待本地P的runnnext字段，若该字段已存在G，则将该G对象存入本地P可运行G列表，若该队列已满，则存于调度器的可运行G队列。 调度器模型 &ensp;在引导程序的初始化时main函数运行的前提，最后阶段，引导程序会促使调度器进行一轮调度，使封装了main函数的G组件得以运行。 &ensp;当调度器在一轮调度之初发现当前M已与某个G锁定，会立刻停止调度并停用(阻塞)该M，这会导致相关的内核线程不得做其他工作，调度器亦不会为当前M寻找可运行G，相当于浪费计算资源；相应的，若调度器找到的可运行G已与某个M锁定，其会唤醒该M以运行锁定的G，并重新为当前M寻找可运行G。 &ensp;当运行遇到串行任务，或等待与之锁定的G，调度器会停止执行调度任务，即阻塞停止当前M直至该串行任务执行完成，此后该M会被再次唤醒，开始新一轮的调度。]]></content>
      <categories>
        <category>Go多进程</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git第二弹]]></title>
    <url>%2F2018%2F05%2F10%2FGit%E7%AC%AC%E4%BA%8C%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[1. 记录每次更新到仓库查看已暂存与未暂存的修改&ensp;命令git diff可以解决两个问题： &ensp;查看已经更新但未暂存的文件&ensp;&ensp;&ensp;使用命令git diff &ensp;查看已经暂存但未提交额文件&ensp;&ensp;&ensp;使用命令git diff --staged &ensp;若修改README文件并暂存，修改CONTRIBUTING.md文件不暂存，此时运行命令git status，显示如下： 123456789101112$ echo "My Project" &gt;&gt; README$ git add README$ echo "# test line" &gt;&gt; CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:(use "git reset HEAD &lt;file&gt;..." to unstage)modified: READMEChanges not staged for commit:(use "git add &lt;file&gt;..." to update what will be committed)(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)modified: CONTRIBUTING.md &ensp;命令git status未显示尚未暂存文件CONTRIBUTING.md更新的具体内容，此时通过命令git diff可查看详细情况，该命令默认情况仅显示未暂存文件的更新部分，所以当暂存了更新文件后，使用该命令未显示任何结果： 123456789$ git diffdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 643e24f..87f08c8 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -119,3 +119,4 @@ at the## Starter ProjectsSee our [projects listhref="https://github.com/libgit2/libgit2/blob/development/PROJECTS.md").+# test line &ensp;若查看已暂存文件README的更新部分,通过加参数命令git diff --staged,显示如下： 12345678$ git diff --stageddiff --git a/README b/READMEnew file mode 100644index 0000000..03902a1--- /dev/null+++ b/README@@ -0,0 +1 @@+My Project &ensp;此时将CONTRIBUTING.md文件暂存，运行命令git diff，显示如下，; 1234567891011121314$ git diff --cacheddiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991..643e24f 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy.Please include a nice description of your changes when you submit your PR;if we have to read the whole diff to figure out why you're contributingin the first place, you're less likely to get feedback and have your change-merged in.+merged in. Also, split your changes into comprehensive chunks if your patch is+longer than a dozen lines.If you are starting to work on a particular area, feel free to submit a PRthat highlights your work in progress (and note in the PR title that it's &ensp;未显示任何结果，因为README和CONTRIBUTING.md文件均已暂存，而git diff默认显示未暂存文件的更新部分。 提交更新&ensp;切记，每次提交前务必运行命令git status查看文件状态，确保文件均已暂存，随后可通过命令git commit -m&quot;更新说明&quot;提交暂存文件，比如： 1234$ git commit -m "Story 182: Fix benchmarks for speed"[master 463dc4f] Story 182: Fix benchmarks for speed2 files changed, 2 insertions(+)create mode 100644 README &ensp;可以看到，本次在master分支执行提交操作，完整 SHA-1 校验和为463dc4f，以及修改及增删的记录，谨记，提交操作仅记录暂存区的快照，未暂存的仍保持已修改状态，每一次提交操作都是对项目的一次快照，便于后续的回溯及比较。 跳过使用暂存区域&ensp;Git通过提供命令git commit -a跳过暂存区，在提交时，自动将所有被跟踪的文件暂存并一并提交，省略了命令git add操作： 12345678910$ git statusOn branch masterChanges not staged for commit:(use "git add &lt;file&gt;..." to update what will be committed)(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)modified: CONTRIBUTING.mdno changes added to commit (use "git add" and/or "git commit -a")$ git commit -a -m 'added new benchmarks'[master 83e38c7] added new benchmarks1 file changed, 5 insertions(+), 0 deletions(-) 移除文件&ensp;由于被跟踪文件在暂存区均存在记录，若想移除某个文件，需将其从暂存区移除，通过命令git rm可以完成，同时删除本地文件，避免其出现在未跟踪文件清单中。 1234567$ git rm PROJECTS.mdrm 'PROJECTS.md'$ git statusOn branch masterChanges to be committed:(use "git reset HEAD &lt;file&gt;..." to unstage)deleted: PROJECTS.md &ensp;如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项-f，这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被Git恢复。当想在磁盘保留文件，但不想该文件被Git跟踪，除了在项目仓库增加.gitignore文件外，还可以通过命令git rm --cached log/\*.log，用于移除log/目录下扩展名为.log的所有文件。 移动文件&ensp;Git通过命令git mv实现文件重命名，比如： 123456$ git mv README.md README$ git statusOn branch masterChanges to be committed:(use "git reset HEAD &lt;file&gt;..." to unstage)renamed: README.md -&gt; README &ensp;该指令相当于执行以下三条指令： 123mv README.md READMEgit rm README.mdgit add README]]></content>
      <categories>
        <category>Git教程</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>集中式版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git第一弹]]></title>
    <url>%2F2018%2F05%2F09%2FGit%E7%AC%AC%E4%B8%80%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[1. 获取Git仓库在现有目录中创建仓库 &ensp;若是管理现有项目，需在项目所在目录通过命令git init进行初始化操作，该命令在项目所在目录生成隐含文件夹.git，包含初始化仓库必要文件，但项目文件并未被跟踪，因此还需跟踪这些文件并提交至仓库。12$ git add .$ git commit -m'修改描述' 克隆现有仓库 &ensp;若想将一已存在仓库克隆值本地，需使用git clone [url]命令，该命令会将远程仓库每一个文件克隆至本地，对于Git可链接库libgit2，可通过日下如下命令实现远程克隆：1$ git clone https://github.com/libgit2/libgit2 &ensp;此时会在当前目录下创建名为libgit2的目录，并在该目录下初始化一个隐含的.git文件，远程仓库拉取的数据均存入.git文件，并从中读取最新版本的文件拷贝。&ensp;若想将libgit2克隆至自定义的仓库mylibgit时，可使用如下命令：1$ git clone https://github.com/libgit2/libgit2 mylibgit &ensp;本次使用的https://协议，Git同时支持多种传输协议，包括git://协议，SSH协议，比如user@server:path/to/repo.git，在服务器上搭建 Git将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。 2. 记录每次更新到仓库&ensp;工作目录下的每一个文件均呈现两种状态，已跟踪或未跟踪。已跟踪文件指被纳入版本控制系统的文件，在上一次快照中存在记录，在工作一段时间后，该文件可能被修改、未修改或存放于暂存区；剩余文件均处于未跟踪状态，均不存在于暂存区及最近一次的快照记录。初次克隆仓库中的文件均处于被跟踪状态。Git会对被修改的文件添加修改标记，Git文件的生命周期如下所示： 检查当前文件状态 &ensp;使用git status命令，对于初始克隆仓库，该命令显示结果如下：123$ git statusOn branch masternothing to commit, working directory clean &ensp;表明工作区很干净，即已跟踪文件未被更改，此外还表明该目录未出现未被跟踪的文件，且当前处于master分支。此时新建README文件，使用git status命令显示如下:1234567$ echo 'My Project' &gt; README$ git statusOn branch masterUntracked files:(use "git add &lt;file&gt;..." to include in what will be committed)READMEnothing added to commit but untracked files present (use "git add" to track) &ensp;状态显示README文件出现在Untracked files区域，表明该文件在之前的快照中不存在，Git不会自动将文件纳入跟踪范围，除非明确告知Git需要跟踪该文件。 跟踪新文件&ensp;git add用于跟踪新文件或已跟踪文件存入暂存区，还能用于合并时把有冲突的文件标记为已解决状态等，将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适，用法如下： &ensp;git add [file]&ensp;&ensp;&ensp;跟踪文件file &ensp;git add [Dir]&ensp;&ensp;&ensp;递归跟踪路径Dir下的所有文件 &ensp;跟踪README文件需使用git add命令，运行如下：1$ git add README &ensp;随后运行git status命令，观察README文件新状态如下：12345$ git statusOn branch masterChanges to be committed:(use "git reset HEAD &lt;file&gt;..." to unstage)new file: README &ensp;Changes to be committed:表明文件README已处于暂存状态，位于暂存区，一旦提交，该文件将被Git快照记录。 暂存已修改文件&ensp;修改已跟踪文件CONTRIBUTING.md，随机运行命令git status，显示如下：123456789$ git statusOn branch masterChanges to be committed:(use "git reset HEAD &lt;file&gt;..." to unstage)new file: READMEChanges not staged for commit:(use "git add &lt;file&gt;..." to update what will be committed)(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)modified: CONTRIBUTING.md &ensp;Changes not staged for commit:表明CONTRIBUTING.md被更改但并未存入暂存区，运行命令git add CONTRIBUTING.md，显示如下：1234567$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:(use "git reset HEAD &lt;file&gt;..." to unstage)new file: READMEmodified: CONTRIBUTING.md &ensp;Changes to be committed:，表明文件CONTRIBUTING.md已被存入暂存区，此时对CONTRIBUTING.md再次修改并存盘，随即运行命令git status，显示如下：1234567891011$ vim CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:(use "git reset HEAD &lt;file&gt;..." to unstage)new file: READMEmodified: CONTRIBUTING.mdChanges not staged for commit:(use "git add &lt;file&gt;..." to update what will be committed)(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)modified: CONTRIBUTING.md &ensp;可以看到CONTRIBUTING.md同时存在于Changes to be committed:与Changes not staged for commit:，因为Git仅暂存了运行git add命令的版本，因此在修改文件后续运行命令git add重新跟踪文件。1234567$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed:(use "git reset HEAD &lt;file&gt;..." to unstage)new file: READMEmodified: CONTRIBUTING.md &ensp;可通过运行命令git status -s获得文件状态的简明报告，输出如下：123456$ git status -sM READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt &ensp;??&ensp;&ensp;LICENSE.txt为新添加的未被跟踪文件 &ensp;M&ensp;&ensp;README在工作区被修改但并未存入暂存区 &ensp;A&ensp;&ensp;lib/git.rb被修改后并添加至暂存区 &ensp;MM&ensp;&ensp;左侧M表示Rakefile被修改并放入暂存区,右侧M表示Rakefile被修改但未存入暂存区,因此Rakefile在工作区被修改并提交到暂存区后又在工作区中被修改了,所以在暂存区和工作区都有该文件被修改了的记录 忽略文件&ensp;对于不想出现在未跟踪文件列表或无需纳入Git管理的文件,可以通过创建文件.gitignore,列出要忽略的文件模式，模式采用shell格式,文件.gitignore 的格式规范如下,更多内容可访问.gitignore文件列表： 所有空行或者以＃开头的行都会被 Git 忽略 可以使用标准的glob模式匹配 匹配模式可以以/开头防止递归 匹配模式可以以/结尾指定目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反 &ensp;所谓的 glob 模式是指 shell所使用的简化了的正则表达式。星号(*)匹配零个或多个任意字符;[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个a,要么匹配一个b,要么匹配一个 c；问号(?)只匹配一个任意字符；[0-9] 匹配所有0到9的数字;使用两个星号(**) 表示匹配任意中间目录,比如a/**/z可以匹配a/z,a/b/z 或 a/b/c/z等。实例如下：123456789101112# no .a files*.a# but do track lib.a, even though you're ignoring .a files above!lib.a# only ignore the TODO file in the current directory, not subdir/TODO/TODO# ignore all files in the build/ directorybuild/# ignore doc/notes.txt, but not doc/server/arch.txtdoc/*.txt# ignore all .pdf files in the doc/ directorydoc/**/*.pdf]]></content>
      <categories>
        <category>Git教程</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>集中式版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post.Check documentation for more info.If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing 支持Markdown Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites Download Now 1$ hexo deploy More info: Deployment var options = {"narrow":false,"autoplay":false,"showlrc":3,"mutex":true,"music":[{"title":"成都","author":"赵雷","url":"http://p7vw4w30r.bkt.clouddn.com/%E8%B5%B5%E9%9B%B7%20-%20%E6%88%90%E9%83%BD.mp3","pic":"http://p7vw4w30r.bkt.clouddn.com/%E6%88%90%E9%83%BD.jpg","lrc":"http://p7vw4w30r.bkt.clouddn.com/%E6%88%90%E9%83%BD_%E6%AD%8C%E8%AF%8D.lrc"}]}; options.element = document.getElementById("aplayer-iSymrxfD"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
  </entry>
</search>
